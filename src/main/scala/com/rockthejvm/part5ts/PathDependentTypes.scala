package com.rockthejvm.part5ts

object PathDependentTypes {

  class Outer {
    class Inner
    object InnerObject
    type InnerType

    def process(arg: Inner) = println(arg)
    def processGeneral(arg: Outer#Inner) = println(arg)
  }

  val outer = new Outer
  val inner = new outer.Inner // outer.Inner is a separate TYPE = path-dependent type

  val outerA = new Outer
  val outerB = new Outer
//  val inner2: outerA.Inner = new outerB.Inner // path-dependent types are DIFFERENT
  val innerA = new outerA.Inner
  val innerB = new outerB.Inner

//  outerA.process(innerB) // same type mismatch
  outer.process(inner) // ok

  // parent-type: Outer#Inner
  outerA.processGeneral(innerA) // ok
  outerA.processGeneral(innerB) // still OK, outerB.Inner <: Outer#Inner
  // Outer#Inner is a type that's synthetically generated by the compiler
  // It is THE PARENT TYPE OF ALL THE POSSIBLE INNER TYPES THAT WE CAN CREATE given the instances of Outer

  /*
    Why:
    - type-checking/type inference (in libraries), e.g. Akka Streams Flow[Int, Int, NotUsed]#Repr - to make sure the compiler can figure out the right types for you
    - type-level programming
  */

  // methods with dependent types: return a different COMPILE-TIME type depending on the argument
  // no need for generics
  trait Record {
    type Key
    def defaultValue: Key
  }

  class StringRecord extends Record {
    override type Key = String
    override def defaultValue: String = ""
  }

  class IntRecord extends Record {
    override type Key = Int
    override def defaultValue: Int = 0
  }

  // user-facing API
  // returns a DIFFERENT TYPE depending on the actual instance of Record
  def getDefaultIdentifier(record: Record): record.Key = record.defaultValue

  val aString: String = getDefaultIdentifier(new StringRecord) // a string
  val anInt: Int = getDefaultIdentifier(new IntRecord) // an int, ok

  // powerful because of better type safety
  // without path-dependent types we would be forced to return Any in getDefaultIdentifier
  // and we'd need to do pattern matching or type casting, so that the record is identified correctly
  // libraries - filled with these kind of examples -> rarely used in user-facing code

  // function with dependent types - from our need to use HOF
  val getIdentifierFunc: Record => Record#Key = getDefaultIdentifier // what kind of function do we have? // eta-expansion -> not trivial at all in the context of abstract type members and path-dependent types

  // Record#Key -> this is the type of parents of all possible records of Key (ofc, they depend on all the defined subtypes of Record)

  def main(args: Array[String]): Unit = {

  }
}
